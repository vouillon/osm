(* OSM tools
 * Copyright (C) 2013 Jérôme Vouillon
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)

(* http://en.wikipedia.org/wiki/Geographical_distance *)
(* http://geographiclib.sourceforge.net/1.1/geodesic.html *)

let haversin th = let s = sin (th /. 2.) in s *. s
let pi = acos (-1.)
let conv_factor = pi /. 180. /. 10_000_000.
let to_rad a = float a *. conv_factor
let r = 6371. *. 1e6

let distance lat1 lon1 lat2 lon2 =
  let lat1 = to_rad lat1 in
  let lon1 = to_rad lon1 in
  let lat2 = to_rad lat2 in
  let lon2 = to_rad lon2 in
  let a =
    haversin (lat2 -. lat1) +.
    cos (lat1) *. cos(lat2) *. haversin (lon2 -. lon1) in
  truncate (2. *. r *. asin (sqrt a))

(*
function lat2y(a) { return 180/Math.PI * Math.log(Math.tan(Math.PI/4+a*(Math.PI/180)/2)); }
*)

(****)

let coeff_1 = 180. /. pi *. 10_000_000.
let pi_4 = pi /. 4.
let coeff_2 = pi /. 180. /. 10_000_000. /. 2.

let lat_to_y lat = coeff_1 *. log (tan (pi_4 +. lat *. coeff_2))

let y_to_lat y = (atan (exp (y /. coeff_1)) -. pi_4) /. coeff_2

(****)

let in_between a b (c : int) = (* c is between a and b *)
  if a <= b then
    (a <= c && c <= b)
  else
    (b <= c && c <= a)

let min x y : int = if x < y then x else y
let max x y : int = if x < y then y else x

let interval_intersect x1 x1' x2 x2' =
  min x1 x1' <= max x2 x2' && min x2 x2' <= max x1 x1'

let segment_intersect x1 y1 x1' y1' x2 y2 x2' y2' =
  let dx1 = x1' - x1 in
  let dy1 = y1' - y1 in
  let dx2 = x2' - x2 in
  let dy2 = y2' - y2 in
  let dx = x2 - x1 in
  let dy = y2 - y1 in
  let d = dx1 * dy2 - dx2 * dy1 in
  let d1 = dx * dy2 - dx2 * dy in
  let d2 = dx * dy1 - dx1 * dy in
  if d <> 0 then begin
    in_between 0 d d1 && in_between 0 d d2
  end else begin
    (* Parallel segments *)
    d1 = 0 && d2 = 0 &&
    begin
      (* Colinear segments *)
      if dx1 = 0 && dx2 = 0 then
        (* Vertical segments *)
        interval_intersect y1 y1' y2 y2'
      else
(*(Format.eprintf "XXX %d %d %d %d@." x1 x1' x2 x2';*)
        interval_intersect x1 x1' x2 x2'
    end
  end

(*
Simple polygons:
  - consecutive segments do not overlap
     dx1*dx2 + dy1* dy2 > 0  ||  dx1*dy2 <> dx2*dy1
  - non-consecutive segments do not intersect
*)

let segment_intersect x1 y1 x1' y1' x2 y2 x2' y2' =
  interval_intersect x1 x1' x2 x2'
    &&
  interval_intersect y1 y1' y2 y2'
    &&
  segment_intersect x1 y1 x1' y1' x2 y2 x2' y2'

(* XXX Use faster algorithm for detecting intersections? *)
let is_simple_polygon px py =
  let l = Array.length px - 1 in
  let res = ref true in
  for i = 1 to l - 1 do
    (* Non-consecutive segments should not intersect *)
    for j = 0 to i - 2 do
      if
        (j > 0 || i < l - 1) &&
        segment_intersect
          px.(i) py.(i) px.(i + 1) py.(i + 1)
          px.(j) py.(j) px.(j + 1) py.(j + 1)
      then
(Format.eprintf "I %d %d: %d %d %d %d %d %d %d %d@." i j
          px.(i) py.(i) px.(i + 1) py.(i + 1)
          px.(j) py.(j) px.(j + 1) py.(j + 1)
;
        res := false
)
    done;
    (* Consecutive segments should not overlap *)
    let dx1 = px.(i + 1) - px.(i) in
    let dy1 = py.(i + 1) - py.(i) in
    let dx2 = px.(i) - px.(i - 1) in
    let dy2 = py.(i) - py.(i - 1) in
    if dx1 * dx2 + dy1 * dy2 <= 0 && dx1 * dy2 = dx2 * dy1 then
(prerr_endline "O";
 res := false
)
  done;
  !res

let point_on_segment x y x1 y1 x1' y1' =
  in_between x1 x1' x &&
  in_between y1 y1' y &&
  let dx1 = x1' - x1 in
  let dy1 = y1' - y1 in
  let dx = x - x1 in
  let dy = y - y1 in
  let d1 = dx * dy1 - dx1 * dy in
  d1 = 0

let point_on_polygon_boundary x y px py =
  let l = Array.length px - 1 in
  let res = ref false in
  for i = 0 to l - 1 do
    if point_on_segment x y px.(i) py.(i) px.(i + 1) py.(i + 1) then
      res := true
  done;
  !res

let point_in_polygon x y px py =
  let n = ref false in
  let l = Array.length px - 1 in
  let pi = ref (py.(0) >= y) in
  for i = 0 to l - 1 do
    let j = i + 1 in
    let pj = py.(j) >= y in
    if (!pi && not pj) || (not !pi && pj) then begin
      let d = 
        (px.(j) - px.(i)) * (y - py.(i)) - (x - px.(i)) * (py.(j) - py.(i))
      in
      let p = (d >= 0) in
      if (p && not !pi) || (not p && !pi) then
        n := not !n
    end;
    pi := pj
  done;
  !n

let midpoint_on_polygon_boundary x1 y1 x2 y2 px py =
  let x = x1 + x2 in
  let y = y1 + y2 in
  let l = Array.length px - 1 in
  let res = ref false in
  for i = 0 to l - 1 do
    if
      point_on_segment x y
        (2 * px.(i)) (2 * py.(i)) (2 * px.(i + 1)) (2 * py.(i + 1))
    then
      res := true
  done;
  !res

let midpoint_in_polygon x1 y1 x2 y2 px py =
  let x = x1 + x2 in
  let y = y1 + y2 in
  let n = ref false in
  let l = Array.length px - 1 in
  let pi = ref (2 * py.(0) >= y) in
  for i = 0 to l - 1 do
    let j = i + 1 in
    let pj = 2 * py.(j) >= y in
    if !pi <> pj then begin
      let d = 
        (px.(j) - px.(i)) * (y - 2 * py.(i)) -
        (x - 2 * px.(i)) * (py.(j) - py.(i))
      in
      if (d >= 0) = !pi then
        n := not !n
    end;
    pi := pj
  done;
  !n

let polygon_area px py =
  let l = Array.length px - 1 in
  let a = ref 0 in
  let x0 = px.(0) in
  let y0 = py.(0) in
  for i = 0 to l - 1 do
    let dx1 = px.(i) - x0 in
    let dy1 = py.(i) - y0 in
    let dx2 = px.(i + 1) - x0 in
    let dy2 = py.(i + 1) - y0 in
    a := !a + dx1 * dy2 - dx2 * dy1
  done;
  (!a + 1) / 2

let polygon_area_float px py =
  let l = Array.length px - 1 in
  let a = ref 0. in
  let x0 = px.(0) in
  let y0 = py.(0) in
  for i = 0 to l - 1 do
    let dx1 = px.(i) -. x0 in
    let dy1 = py.(i) -. y0 in
    let dx2 = px.(i + 1) -. x0 in
    let dy2 = py.(i + 1) -. y0 in
    a := !a +. dx1 *. dy2 -. dx2 *. dy1
  done;
  !a /. 2.

(*
polygon containment:
- assumption :
  either contained or with disjoint interior;
  in fact, edge intersection only on edge extremities, or same edge
==> we have a point inside but not on boundary
==> or, we have a segment midpoint inside but not on boundary
*)

exception Success

(* Slow version: in most cases, returns true when some part of the
   first polygon is in the second polygon *)
let polygon_in_polygon (px, py) (px', py') =
  try
    let l = Array.length px in
    let on_boundary =
      Array.init l
        (fun i ->
           if point_on_polygon_boundary px.(i) py.(i) px' py' then
             true
           else if point_in_polygon px.(i) py.(i) px' py' then
             raise Success
           else
             false)
    in
    for i = 0 to l - 2 do
      if
        on_boundary.(i) && on_boundary.(i + 1) &&
        not (midpoint_on_polygon_boundary
               px.(i) py.(i) px.(i + 1) py.(i + 1) px' py') &&
        midpoint_in_polygon
          px.(i) py.(i) px.(i + 1) py.(i + 1) px' py'
      then
        raise Success
    done;
    false
  with Success ->
    true

exception Failure

(* Fast version: unspecified result when polygon overlaps *)
let polygon_in_polygon (px, py) (px', py') =
  try
    let l = Array.length px in
    for i = 0 to l - 1 do
      if not (point_on_polygon_boundary px.(i) py.(i) px' py') then begin
        if point_in_polygon px.(i) py.(i) px' py' then
          raise Success
        else
          raise Failure
      end
    done;
    for i = 0 to l - 2 do
      if
        not (midpoint_on_polygon_boundary
               px.(i) py.(i) px.(i + 1) py.(i + 1) px' py')
      then begin
        if
          midpoint_in_polygon
            px.(i) py.(i) px.(i + 1) py.(i + 1) px' py'
        then
          raise Success
        else
          raise Failure
      end;
    done;
    false
  with
    Success ->
      true
  | Failure ->
      false

let polygon_mostly_in_polygon (px, py) (px', py') =
  let l = Array.length px in
  let on_boundary =
    Array.init l
      (fun i -> point_on_polygon_boundary px.(i) py.(i) px' py')
  in
  let total = ref 0 in
  let inside = ref 0 in
  for i = 0 to l - 2 do
    if not on_boundary.(i) then begin
      if point_in_polygon px.(i) py.(i) px' py' then
        incr inside;
      incr total
    end
  done;
  if !total = 0 then begin
    for i = 0 to l - 2 do
      if
        on_boundary.(i) && on_boundary.(i + 1) &&
        not (midpoint_on_polygon_boundary
               px.(i) py.(i) px.(i + 1) py.(i + 1) px' py')
      then begin
        if
          midpoint_in_polygon
            px.(i) py.(i) px.(i + 1) py.(i + 1) px' py'
        then
          incr inside;
        incr total
      end
    done
  end;
(*Format.eprintf "POS: %d/%d (%d)@." !inside !total l;*)
  !total = 0 || float !inside /. float !total >= 0.7

(****)

let bytes =
  [|0x00; 0x03; 0x04; 0x05; 0x3a; 0x3b; 0x3c; 0x3f;
    0x40; 0x41; 0x4e; 0x4f; 0x50; 0x53; 0x54; 0x55;
    0x01; 0x02; 0x07; 0x06; 0x39; 0x38; 0x3d; 0x3e;
    0x43; 0x42; 0x4d; 0x4c; 0x51; 0x52; 0x57; 0x56;
    0x0e; 0x0d; 0x08; 0x09; 0x36; 0x37; 0x32; 0x31;
    0x44; 0x47; 0x48; 0x4b; 0x5e; 0x5d; 0x58; 0x59;
    0x0f; 0x0c; 0x0b; 0x0a; 0x35; 0x34; 0x33; 0x30;
    0x45; 0x46; 0x49; 0x4a; 0x5f; 0x5c; 0x5b; 0x5a;
    0x10; 0x11; 0x1e; 0x1f; 0x20; 0x21; 0x2e; 0x2f;
    0x7a; 0x79; 0x76; 0x75; 0x60; 0x63; 0x64; 0x65;
    0x13; 0x12; 0x1d; 0x1c; 0x23; 0x22; 0x2d; 0x2c;
    0x7b; 0x78; 0x77; 0x74; 0x61; 0x62; 0x67; 0x66;
    0x14; 0x17; 0x18; 0x1b; 0x24; 0x27; 0x28; 0x2b;
    0x7c; 0x7d; 0x72; 0x73; 0x6e; 0x6d; 0x68; 0x69;
    0x15; 0x16; 0x19; 0x1a; 0x25; 0x26; 0x29; 0x2a;
    0x7f; 0x7e; 0x71; 0x70; 0x6f; 0x6c; 0x6b; 0x6a;
    0xea; 0xe9; 0xe6; 0xe5; 0xda; 0xd9; 0xd6; 0xd5;
    0x80; 0x81; 0x8e; 0x8f; 0x90; 0x93; 0x94; 0x95;
    0xeb; 0xe8; 0xe7; 0xe4; 0xdb; 0xd8; 0xd7; 0xd4;
    0x83; 0x82; 0x8d; 0x8c; 0x91; 0x92; 0x97; 0x96;
    0xec; 0xed; 0xe2; 0xe3; 0xdc; 0xdd; 0xd2; 0xd3;
    0x84; 0x87; 0x88; 0x8b; 0x9e; 0x9d; 0x98; 0x99;
    0xef; 0xee; 0xe1; 0xe0; 0xdf; 0xde; 0xd1; 0xd0;
    0x85; 0x86; 0x89; 0x8a; 0x9f; 0x9c; 0x9b; 0x9a;
    0xf0; 0xf3; 0xf4; 0xf5; 0xca; 0xcb; 0xcc; 0xcf;
    0xba; 0xb9; 0xb6; 0xb5; 0xa0; 0xa3; 0xa4; 0xa5;
    0xf1; 0xf2; 0xf7; 0xf6; 0xc9; 0xc8; 0xcd; 0xce;
    0xbb; 0xb8; 0xb7; 0xb4; 0xa1; 0xa2; 0xa7; 0xa6;
    0xfe; 0xfd; 0xf8; 0xf9; 0xc6; 0xc7; 0xc2; 0xc1;
    0xbc; 0xbd; 0xb2; 0xb3; 0xae; 0xad; 0xa8; 0xa9;
    0xff; 0xfc; 0xfb; 0xfa; 0xc5; 0xc4; 0xc3; 0xc0;
    0xbf; 0xbe; 0xb1; 0xb0; 0xaf; 0xac; 0xab; 0xaa;
    0x00; 0x01; 0x0e; 0x0f; 0x10; 0x13; 0x14; 0x15;
    0xea; 0xeb; 0xec; 0xef; 0xf0; 0xf1; 0xfe; 0xff;
    0x03; 0x02; 0x0d; 0x0c; 0x11; 0x12; 0x17; 0x16;
    0xe9; 0xe8; 0xed; 0xee; 0xf3; 0xf2; 0xfd; 0xfc;
    0x04; 0x07; 0x08; 0x0b; 0x1e; 0x1d; 0x18; 0x19;
    0xe6; 0xe7; 0xe2; 0xe1; 0xf4; 0xf7; 0xf8; 0xfb;
    0x05; 0x06; 0x09; 0x0a; 0x1f; 0x1c; 0x1b; 0x1a;
    0xe5; 0xe4; 0xe3; 0xe0; 0xf5; 0xf6; 0xf9; 0xfa;
    0x3a; 0x39; 0x36; 0x35; 0x20; 0x23; 0x24; 0x25;
    0xda; 0xdb; 0xdc; 0xdf; 0xca; 0xc9; 0xc6; 0xc5;
    0x3b; 0x38; 0x37; 0x34; 0x21; 0x22; 0x27; 0x26;
    0xd9; 0xd8; 0xdd; 0xde; 0xcb; 0xc8; 0xc7; 0xc4;
    0x3c; 0x3d; 0x32; 0x33; 0x2e; 0x2d; 0x28; 0x29;
    0xd6; 0xd7; 0xd2; 0xd1; 0xcc; 0xcd; 0xc2; 0xc3;
    0x3f; 0x3e; 0x31; 0x30; 0x2f; 0x2c; 0x2b; 0x2a;
    0xd5; 0xd4; 0xd3; 0xd0; 0xcf; 0xce; 0xc1; 0xc0;
    0x40; 0x43; 0x44; 0x45; 0x7a; 0x7b; 0x7c; 0x7f;
    0x80; 0x83; 0x84; 0x85; 0xba; 0xbb; 0xbc; 0xbf;
    0x41; 0x42; 0x47; 0x46; 0x79; 0x78; 0x7d; 0x7e;
    0x81; 0x82; 0x87; 0x86; 0xb9; 0xb8; 0xbd; 0xbe;
    0x4e; 0x4d; 0x48; 0x49; 0x76; 0x77; 0x72; 0x71;
    0x8e; 0x8d; 0x88; 0x89; 0xb6; 0xb7; 0xb2; 0xb1;
    0x4f; 0x4c; 0x4b; 0x4a; 0x75; 0x74; 0x73; 0x70;
    0x8f; 0x8c; 0x8b; 0x8a; 0xb5; 0xb4; 0xb3; 0xb0;
    0x50; 0x51; 0x5e; 0x5f; 0x60; 0x61; 0x6e; 0x6f;
    0x90; 0x91; 0x9e; 0x9f; 0xa0; 0xa1; 0xae; 0xaf;
    0x53; 0x52; 0x5d; 0x5c; 0x63; 0x62; 0x6d; 0x6c;
    0x93; 0x92; 0x9d; 0x9c; 0xa3; 0xa2; 0xad; 0xac;
    0x54; 0x57; 0x58; 0x5b; 0x64; 0x67; 0x68; 0x6b;
    0x94; 0x97; 0x98; 0x9b; 0xa4; 0xa7; 0xa8; 0xab;
    0x55; 0x56; 0x59; 0x5a; 0x65; 0x66; 0x69; 0x6a;
    0x95; 0x96; 0x99; 0x9a; 0xa5; 0xa6; 0xa9; 0xaa;
    0xaa; 0xab; 0xac; 0xaf; 0xb0; 0xb1; 0xbe; 0xbf;
    0xc0; 0xc3; 0xc4; 0xc5; 0xfa; 0xfb; 0xfc; 0xff;
    0xa9; 0xa8; 0xad; 0xae; 0xb3; 0xb2; 0xbd; 0xbc;
    0xc1; 0xc2; 0xc7; 0xc6; 0xf9; 0xf8; 0xfd; 0xfe;
    0xa6; 0xa7; 0xa2; 0xa1; 0xb4; 0xb7; 0xb8; 0xbb;
    0xce; 0xcd; 0xc8; 0xc9; 0xf6; 0xf7; 0xf2; 0xf1;
    0xa5; 0xa4; 0xa3; 0xa0; 0xb5; 0xb6; 0xb9; 0xba;
    0xcf; 0xcc; 0xcb; 0xca; 0xf5; 0xf4; 0xf3; 0xf0;
    0x9a; 0x9b; 0x9c; 0x9f; 0x8a; 0x89; 0x86; 0x85;
    0xd0; 0xd1; 0xde; 0xdf; 0xe0; 0xe1; 0xee; 0xef;
    0x99; 0x98; 0x9d; 0x9e; 0x8b; 0x88; 0x87; 0x84;
    0xd3; 0xd2; 0xdd; 0xdc; 0xe3; 0xe2; 0xed; 0xec;
    0x96; 0x97; 0x92; 0x91; 0x8c; 0x8d; 0x82; 0x83;
    0xd4; 0xd7; 0xd8; 0xdb; 0xe4; 0xe7; 0xe8; 0xeb;
    0x95; 0x94; 0x93; 0x90; 0x8f; 0x8e; 0x81; 0x80;
    0xd5; 0xd6; 0xd9; 0xda; 0xe5; 0xe6; 0xe9; 0xea;
    0x6a; 0x6b; 0x6c; 0x6f; 0x70; 0x71; 0x7e; 0x7f;
    0x2a; 0x29; 0x26; 0x25; 0x1a; 0x19; 0x16; 0x15;
    0x69; 0x68; 0x6d; 0x6e; 0x73; 0x72; 0x7d; 0x7c;
    0x2b; 0x28; 0x27; 0x24; 0x1b; 0x18; 0x17; 0x14;
    0x66; 0x67; 0x62; 0x61; 0x74; 0x77; 0x78; 0x7b;
    0x2c; 0x2d; 0x22; 0x23; 0x1c; 0x1d; 0x12; 0x13;
    0x65; 0x64; 0x63; 0x60; 0x75; 0x76; 0x79; 0x7a;
    0x2f; 0x2e; 0x21; 0x20; 0x1f; 0x1e; 0x11; 0x10;
    0x5a; 0x5b; 0x5c; 0x5f; 0x4a; 0x49; 0x46; 0x45;
    0x30; 0x33; 0x34; 0x35; 0x0a; 0x0b; 0x0c; 0x0f;
    0x59; 0x58; 0x5d; 0x5e; 0x4b; 0x48; 0x47; 0x44;
    0x31; 0x32; 0x37; 0x36; 0x09; 0x08; 0x0d; 0x0e;
    0x56; 0x57; 0x52; 0x51; 0x4c; 0x4d; 0x42; 0x43;
    0x3e; 0x3d; 0x38; 0x39; 0x06; 0x07; 0x02; 0x01;
    0x55; 0x54; 0x53; 0x50; 0x4f; 0x4e; 0x41; 0x40;
    0x3f; 0x3c; 0x3b; 0x3a; 0x05; 0x04; 0x03; 0x00;
    0xaa; 0xa9; 0xa6; 0xa5; 0x9a; 0x99; 0x96; 0x95;
    0x6a; 0x69; 0x66; 0x65; 0x5a; 0x59; 0x56; 0x55;
    0xab; 0xa8; 0xa7; 0xa4; 0x9b; 0x98; 0x97; 0x94;
    0x6b; 0x68; 0x67; 0x64; 0x5b; 0x58; 0x57; 0x54;
    0xac; 0xad; 0xa2; 0xa3; 0x9c; 0x9d; 0x92; 0x93;
    0x6c; 0x6d; 0x62; 0x63; 0x5c; 0x5d; 0x52; 0x53;
    0xaf; 0xae; 0xa1; 0xa0; 0x9f; 0x9e; 0x91; 0x90;
    0x6f; 0x6e; 0x61; 0x60; 0x5f; 0x5e; 0x51; 0x50;
    0xb0; 0xb3; 0xb4; 0xb5; 0x8a; 0x8b; 0x8c; 0x8f;
    0x70; 0x73; 0x74; 0x75; 0x4a; 0x4b; 0x4c; 0x4f;
    0xb1; 0xb2; 0xb7; 0xb6; 0x89; 0x88; 0x8d; 0x8e;
    0x71; 0x72; 0x77; 0x76; 0x49; 0x48; 0x4d; 0x4e;
    0xbe; 0xbd; 0xb8; 0xb9; 0x86; 0x87; 0x82; 0x81;
    0x7e; 0x7d; 0x78; 0x79; 0x46; 0x47; 0x42; 0x41;
    0xbf; 0xbc; 0xbb; 0xba; 0x85; 0x84; 0x83; 0x80;
    0x7f; 0x7c; 0x7b; 0x7a; 0x45; 0x44; 0x43; 0x40;
    0xc0; 0xc1; 0xce; 0xcf; 0xd0; 0xd3; 0xd4; 0xd5;
    0x2a; 0x2b; 0x2c; 0x2f; 0x30; 0x31; 0x3e; 0x3f;
    0xc3; 0xc2; 0xcd; 0xcc; 0xd1; 0xd2; 0xd7; 0xd6;
    0x29; 0x28; 0x2d; 0x2e; 0x33; 0x32; 0x3d; 0x3c;
    0xc4; 0xc7; 0xc8; 0xcb; 0xde; 0xdd; 0xd8; 0xd9;
    0x26; 0x27; 0x22; 0x21; 0x34; 0x37; 0x38; 0x3b;
    0xc5; 0xc6; 0xc9; 0xca; 0xdf; 0xdc; 0xdb; 0xda;
    0x25; 0x24; 0x23; 0x20; 0x35; 0x36; 0x39; 0x3a;
    0xfa; 0xf9; 0xf6; 0xf5; 0xe0; 0xe3; 0xe4; 0xe5;
    0x1a; 0x1b; 0x1c; 0x1f; 0x0a; 0x09; 0x06; 0x05;
    0xfb; 0xf8; 0xf7; 0xf4; 0xe1; 0xe2; 0xe7; 0xe6;
    0x19; 0x18; 0x1d; 0x1e; 0x0b; 0x08; 0x07; 0x04;
    0xfc; 0xfd; 0xf2; 0xf3; 0xee; 0xed; 0xe8; 0xe9;
    0x16; 0x17; 0x12; 0x11; 0x0c; 0x0d; 0x02; 0x03;
    0xff; 0xfe; 0xf1; 0xf0; 0xef; 0xec; 0xeb; 0xea;
    0x15; 0x14; 0x13; 0x10; 0x0f; 0x0e; 0x01; 0x00|]

let quadrant =
  [|0;2;1;0;2;1;0;2;1;0;2;1;0;2;1;0;1;1;3;0;2;3;1;1;3;0;2;3;1;1;3;0;
    3;3;1;0;2;1;3;3;0;2;0;2;3;3;1;0;0;2;3;0;2;3;0;2;1;1;1;1;0;2;3;0;
    1;0;2;1;1;0;2;1;3;3;3;3;0;2;1;0;3;0;2;3;3;0;2;3;0;2;0;2;1;1;3;0;
    0;2;0;2;0;2;0;2;1;0;2;1;3;3;1;0;1;1;1;1;1;1;1;1;3;0;2;3;0;2;3;0;
    3;3;3;3;3;3;3;3;1;0;2;1;0;2;1;0;0;2;0;2;0;2;0;2;3;0;2;3;1;1;3;0;
    1;0;2;1;1;0;2;1;0;2;0;2;3;3;1;0;3;0;2;3;3;0;2;3;1;1;1;1;0;2;3;0;
    0;2;1;0;2;1;0;2;3;3;3;3;0;2;1;0;1;1;3;0;2;3;1;1;0;2;0;2;1;1;3;0;
    3;3;1;0;2;1;3;3;1;0;2;1;3;3;1;0;0;2;3;0;2;3;0;2;3;0;2;3;0;2;3;0;
    1;0;2;1;0;2;1;0;2;1;0;2;1;0;2;1;3;0;2;3;1;1;3;0;2;3;1;1;3;0;2;3;
    0;2;0;2;3;3;1;0;2;1;3;3;0;2;0;2;1;1;1;1;0;2;3;0;2;3;0;2;1;1;1;1;
    3;3;3;3;0;2;1;0;2;1;0;2;3;3;3;3;0;2;0;2;1;1;3;0;2;3;1;1;0;2;0;2;
    1;0;2;1;3;3;1;0;2;1;3;3;1;0;2;1;3;0;2;3;0;2;3;0;2;3;0;2;3;0;2;3;
    0;2;1;0;2;1;0;2;0;2;1;0;2;1;0;2;1;1;3;0;2;3;1;1;1;1;3;0;2;3;1;1;
    3;3;1;0;2;1;3;3;3;3;1;0;2;1;3;3;0;2;3;0;2;3;0;2;0;2;3;0;2;3;0;2;
    1;0;2;1;1;0;2;1;1;0;2;1;1;0;2;1;3;0;2;3;3;0;2;3;3;0;2;3;3;0;2;3;
    0;2;0;2;0;2;0;2;0;2;0;2;0;2;0;2;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;
    2;1;0;2;1;0;2;1;0;2;1;0;2;1;0;2;2;3;1;1;3;0;2;3;1;1;3;0;2;3;1;1;
    2;1;3;3;0;2;0;2;3;3;1;0;2;1;3;3;2;3;0;2;1;1;1;1;0;2;3;0;2;3;0;2;
    2;1;0;2;3;3;3;3;1;0;2;1;1;0;2;1;2;3;1;1;0;2;0;2;3;0;2;3;3;0;2;3;
    2;1;3;3;1;0;2;1;0;2;0;2;0;2;0;2;2;3;0;2;3;0;2;3;1;1;1;1;1;1;1;1;
    2;1;0;2;1;0;2;1;3;3;3;3;3;3;3;3;2;3;1;1;3;0;2;3;0;2;0;2;0;2;0;2;
    2;1;3;3;0;2;0;2;1;0;2;1;1;0;2;1;2;3;0;2;1;1;1;1;3;0;2;3;3;0;2;3;
    2;1;0;2;3;3;3;3;0;2;1;0;2;1;0;2;2;3;1;1;0;2;0;2;1;1;3;0;2;3;1;1;
    2;1;3;3;1;0;2;1;3;3;1;0;2;1;3;3;2;3;0;2;3;0;2;3;0;2;3;0;2;3;0;2;
    3;3;3;3;3;3;3;3;3;3;3;3;3;3;3;3;0;2;0;2;0;2;0;2;0;2;0;2;0;2;0;2;
    1;0;2;1;1;0;2;1;1;0;2;1;1;0;2;1;3;0;2;3;3;0;2;3;3;0;2;3;3;0;2;3;
    0;2;1;0;2;1;0;2;0;2;1;0;2;1;0;2;1;1;3;0;2;3;1;1;1;1;3;0;2;3;1;1;
    3;3;1;0;2;1;3;3;3;3;1;0;2;1;3;3;0;2;3;0;2;3;0;2;0;2;3;0;2;3;0;2;
    1;0;2;1;0;2;1;0;2;1;0;2;1;0;2;1;3;0;2;3;1;1;3;0;2;3;1;1;3;0;2;3;
    0;2;0;2;3;3;1;0;2;1;3;3;0;2;0;2;1;1;1;1;0;2;3;0;2;3;0;2;1;1;1;1;
    3;3;3;3;0;2;1;0;2;1;0;2;3;3;3;3;0;2;0;2;1;1;3;0;2;3;1;1;0;2;0;2;
    1;0;2;1;3;3;1;0;2;1;3;3;1;0;2;1;3;0;2;3;0;2;3;0;2;3;0;2;3;0;2;3|]

let hilbert_coordinate x y =
  let x = ref x in
  let y = ref y in
  let z = ref 0 in
  let n = ref 0 in
  for i = 0 to 7 do
    let j = ((!x lsr 24) land 0xf0) lor ((!y lsr 28) land 0xf) lor !n in
    x := !x lsl 4;
    y := !y lsl 4;
    n := (Array.unsafe_get quadrant j) lsl 8;
    z := (!z lsl 8) lor (Array.unsafe_get bytes j)
  done;
  !z - min_int (* offset so that we can use signed comparison *)

(* http://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN *)
let dilate x =
  let x = (x lor (x lsl 16)) land 0x0000FFFF0000FFFF in
  let x = (x lor (x lsl 8)) land  0x00FF00FF00FF00FF in
  let x = (x lor (x lsl 4)) land  0x0F0F0F0F0F0F0F0F in
  let x = (x lor (x lsl 2)) land  0x3333333333333333 in
  let x = (x lor (x lsl 1)) land  0x5555555555555555 in
  x

(* Faster to compute but not as good as Hilbert coordinates *)
let z_order x y = (((dilate x) lsl 1) lor (dilate y)) - min_int
